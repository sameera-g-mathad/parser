services:
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile.dev

    restart: always

    depends_on:
      client:
        condition: service_started

      api:
        condition: service_started

    # 3050 is the port of local machine,
    # i.e you can access using http://localhost:3050 from
    # now.
    ports:
      - 3050:80
  client:
    build:
      context: ./client
      dockerfile: Dockerfile.dev

    ports:
      - 3000:3000

    volumes:
      - /app/node_modules
      - ./client:/app

  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev

    # Depends on postgres and redis.
    # Will wait until both the containers
    # send healthy status before starting.
    # In this case, we want to start the server
    # only if databases are ready.
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

    env_file:
      - ./.env
      - ./api/.env

    ports:
      - 4000:4000

    volumes:
      - /app/node_modules
      - ./api:/app
      - shared_uploads:/shared # api and worker will share a volume to process uploaded files.

  # worker container to handle tasks,
  # such as sending emails, creating embeddings.
  worker:
    build:
      context: ./worker
      dockerfile: Dockerfile.dev

    depends_on:
      redis:
        condition: service_healthy

      postgres:
        condition: service_healthy

    env_file:
      - ./.env
      - ./worker/.env

    volumes:
      - /app/node_modules
      - ./worker:/app
      - shared_uploads:/shared # api and worker will share a volume to process uploaded files.

  postgres:
    # image: postgres:17-alpine
    # adding custom dockerfile to use embeddings.
    # build:
    #   context: ./postgres
    #   dockerfile: Dockerfile.dev

    # using pgvector to use both postgres and pgvector.
    image: pgvector/pgvector:pg17
    # Do this so that the db runs succesfully.
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_USER=postgres

    # Health check: Docker will test the cmd for _ intervals for _ seconds
    # for _ retries. This is needed for other servies dependent on this
    # image to start.
    healthcheck:
      test: ['CMD', 'pg_isready', '-U', 'postgres']
      interval: 5s
      timeout: 5s
      retries: 5

    ports:
      - 5432:5432

    # uncomment once the schema is finalized.
    volumes:
      - postgres_db:/var/lib/postgresql/data
      - ./postgres/schema.sql:/docker-entrypoint-initdb.d/schema.sql

  redis:
    image: redis:8-alpine

    # Health check: Docker will test the cmd for _ intervals for _ seconds
    # for _ retries. This is needed for other servies dependent on this
    # image to start.
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 5s
      retries: 5

    ports:
      - 6379:6379

volumes:
  postgres_db:
  shared_uploads: # this will help in storing uploads from the server.
