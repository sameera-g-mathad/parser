# Production docker compose file.
# only nginx port should be open.
services:
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile

    restart: always

    depends_on:
      client:
        condition: service_started

      api:
        condition: service_started

    # 80 is the port to accept requests,
    # i.e you can access using http://website:80 from
    # now.
    ports:
      - 80:80
      - 443:443

    volumes:
      - /etc/letsencrypt:/etc/letsencrypt:ro

  client:
    build:
      context: ./client
      dockerfile: Dockerfile

    restart: always

  api:
    build:
      context: ./api
      dockerfile: Dockerfile

    # Depends on postgres and redis.
    # Will wait until both the containers
    # send healthy status before starting.
    # In this case, we want to start the server
    # only if databases are ready.
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

    env_file:
      - ./.env
      - ./api/.env

    restart: always

    volumes:
      - shared_uploads:/shared # api and worker will share a volume to process uploaded files.

  # worker container to handle tasks,
  # such as sending emails, creating embeddings.
  worker:
    build:
      context: ./worker
      dockerfile: Dockerfile

    depends_on:
      redis:
        condition: service_healthy

      postgres:
        condition: service_healthy

    env_file:
      - ./.env
      - ./worker/.env

    restart: always

    volumes:
      - shared_uploads:/shared # api and worker will share a volume to process uploaded files.

  postgres:
    # using pgvector to use both postgres and pgvector.
    image: pgvector/pgvector:pg17
    # Do this so that the db runs succesfully.
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_USER=postgres

    # Health check: Docker will test the cmd for _ intervals for _ seconds
    # for _ retries. This is needed for other servies dependent on this
    # image to start.
    healthcheck:
      test: ['CMD', 'pg_isready', '-U', 'postgres']
      interval: 5s
      timeout: 5s
      retries: 5

    restart: always

    # uncomment once the schema is finalized.
    volumes:
      - postgres_db:/var/lib/postgresql/data
      - ./postgres/schema.sql:/docker-entrypoint-initdb.d/schema.sql

  redis:
    image: redis:8-alpine

    # Health check: Docker will test the cmd for _ intervals for _ seconds
    # for _ retries. This is needed for other servies dependent on this
    # image to start.
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 5s
      retries: 5

    restart: always

volumes:
  postgres_db:
  shared_uploads: # this will help in storing uploads from the server.

